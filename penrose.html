<?DOCTYPE html?>
<html>
<head>
    <script type="text/x-shader" id="vertex-shader-src">
    precision mediump float;

    uniform float aspect;

    attribute vec2 vertexPosition;
    varying vec2 fragmentPosition;

    void main() {
        // convert the 2d position to a 4d vector, scaled by aspect ratio
        gl_Position = vec4(vertexPosition.x, vertexPosition.y * aspect, 0, 1);
        // interpolate coords over the whole screen
        fragmentPosition = vertexPosition;
    }
    </script>
    <script type="text/x-shader" id="fragment-shader-src">
    precision mediump float;

    uniform float time;

    varying vec2 fragmentPosition;

    const vec4 KITE_COLOUR = vec4(0, 153, 51, 255) / 255.;
    const vec4 DART_COLOUR = vec4(102, 204, 255, 255) / 255.;

    const float PI = 3.1415926535898;
    const float EDGE = 0.002;

    const float PHI = (1. + sqrt(5.)) / 2.;
    const float PHI_INV = 1. / PHI;

    const int NONE = 0;
    const int HALF_DART = 1; // sitting on wide base, t0 is bottom-left, t1 is bottom-right, t2 is top
    const int HALF_KITE = 2; // sitting on narrow base, t0 is bottom-left, t1 is bottom-right, t2 is top

    const int ITERATIONS = 11;

/*
half kite:
 short base: 1
 long sides: 1.61803399
 narrow top angle: 0.628318531
 wide base angles: 1.25663706 (sin = 0.95105651585, cos = 0.30901699574)

half dart:
 short sides: 1
 long base: 1.61803399
 wide top angle: 1.88495559
 narrow base angles: 0.62831853 (sin = 0.58778525171)
 left division is kite, right division is dart
*/

    // Returns -1 if v2 is anticlockwise of v1, 1 if clockwise
    float cross2d(vec2 origin, vec2 v1, vec2 v2) {
        vec3 line1 = vec3(v1 - origin, 0);
        vec3 line2 = vec3(v2 - origin, 0);
        return cross(line1, line2).z;
    }

    void main() {
        // Starting half-kite that fills the screen.
        int triangleType = HALF_KITE;
        float scale = 1.;
        vec2 t2 = vec2(-7.5, -2.5) * scale;
        vec2 t0 = vec2(2.5, -2.5) * scale;
        vec2 t1 = vec2(0.954915021, 2.25528257925) * scale;
        float sign = 1.;
        float minc = 1.; // This tracks the distance from the fragmentPosition to the nearest tile edge

        for (int i = 0; i < ITERATIONS; i++) {
            if (sign * cross2d(t0, t1, fragmentPosition) < 0. ||
                sign * cross2d(t0, t2, fragmentPosition) > 0. ||
                sign * cross2d(t1, t2, fragmentPosition) < 0.) {

                triangleType = NONE;
            } else if (triangleType == HALF_DART) {
                vec2 p0 = t2; // apex of the triangle, sitting on its wide base
                vec2 p1 = t0 + PHI_INV * (t1 - t0); // point near the right of the base

                float c = cross2d(p1, p0, fragmentPosition);
                if (sign * c < 0.) {
                    t0 = t1;
                    t1 = t2;
                    t2 = p1;
                    triangleType = HALF_DART;
                } else {
                    vec2 tmp = t0;
                    t0 = t2;
                    t2 = tmp;
                    t1 = p1;
                    triangleType = HALF_KITE;
                    sign *= -1.; // this one is flipped
                }
                minc = min(minc, abs(c) / length(p1 - p0));
            } else {
                vec2 p0 = t2 + PHI_INV * (t0 - t2); // point near the bottom of the left side
                vec2 p1 = t1 + PHI_INV * (t2 - t1); // point near the top of the right side
                vec2 p2 = t1; // this point divides the two kite halves: bottom-left corner

                vec3 line1 = vec3(p1 - p0, 0);
                vec3 line2 = vec3(fragmentPosition - p0, 0);
                vec3 line3 = vec3(p2 - p0, 0);

                float c = cross2d(p0, p1, fragmentPosition);
                float d = cross2d(p0, p2, fragmentPosition);
                if (sign * c > 0.) {
                    t0 = t2;
                    t1 = p0;
                    t2 = p1;
                    triangleType = HALF_DART;
                } else if (sign * d > 0.) {
                    t2 = t1;
                    t0 = p0;
                    t1 = p1;
                    triangleType = HALF_KITE;
                    sign *= -1.; // this one is flipped
                } else {
                    t2 = t1;
                    t1 = t0;
                    t0 = p0;
                    triangleType = HALF_KITE;
                }
                minc = min(minc, abs(c) / length(p0 - p1));
                minc = min(minc, abs(d) / length(p0 - p2));
            }
        }

        vec4 colour;
        if (triangleType == NONE) {
            colour = vec4(0, 0, 0, 255);
        } else if (triangleType == HALF_DART) {
            colour = DART_COLOUR;
        } else {
            colour = KITE_COLOUR;
        }
        if (minc < EDGE) {
            gl_FragColor = mix(colour, vec4(0., 0., 0., 255.), 1. - minc / EDGE);
        } else {
            gl_FragColor = colour;
        }
    }
    </script>
    <script src="jquery-2.1.4.js"></script>
    <script src="webgl.js"></script>
</head>
<body>
    <canvas width="1024" height="720"></canvas>
</body>
</html>
