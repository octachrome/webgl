<?DOCTYPE html?>
<html>
<head>
    <script type="text/x-shader" id="vertex-shader-src">
    precision mediump float;

    uniform float aspect;

    attribute vec2 vertexPosition;
    varying vec2 fragmentPosition;

    void main() {
        // convert the 2d position to a 4d vector, scaled by aspect ratio
        gl_Position = vec4(vertexPosition.x, vertexPosition.y * aspect, 0, 1);
        // interpolate coords over the whole screen
        fragmentPosition = vertexPosition;
    }
    </script>
    <script type="text/x-shader" id="fragment-shader-src">
    precision mediump float;

    uniform float time;
    uniform vec2 start_t0;
    uniform vec2 start_t1;
    uniform vec2 start_t2;
    uniform float start_sign;
    uniform int start_triangleType;

    varying vec2 fragmentPosition;

    const vec4 KITE_COLOUR = vec4(0, 153, 51, 255) / 255.;
    const vec4 DART_COLOUR = vec4(102, 204, 255, 255) / 255.;
    const vec4 EDGE_COLOUR = vec4(255, 12, 12, 255) / 255.;

    const float PI = 3.1415926535898;
    const float EDGE = 0.002;

    const float PHI = (1. + sqrt(5.)) / 2.;
    const float PHI_INV = 1. / PHI;

    const int NONE = 0;
    const int HALF_DART = 1; // sitting on wide base, t0 is bottom-left, t1 is bottom-right, t2 is top
    const int HALF_KITE = 2; // sitting on narrow base, t0 is bottom-left, t1 is bottom-right, t2 is top

    const int ITERATIONS = 11;

/*
half kite:
 short base: 1
 long sides: 1.61803399
 narrow top angle: 0.628318531
 wide base angles: 1.25663706 (sin = 0.95105651585, cos = 0.30901699574)

half dart:
 short sides: 1
 long base: 1.61803399
 wide top angle: 1.88495559
 narrow base angles: 0.62831853 (sin = 0.58778525171)
 left division is kite, right division is dart
*/

    // Returns -1 if v2 is anticlockwise of v1, 1 if clockwise
    float cross2d(vec2 origin, vec2 v1, vec2 v2) {
        vec3 line1 = vec3(v1 - origin, 0);
        vec3 line2 = vec3(v2 - origin, 0);
        return cross(line1, line2).z;
    }

    vec4 calcColour(int triangleType, vec2 t0, vec2 t1, vec2 t2) {
        vec4 colour;
        if (triangleType == HALF_DART) {
            colour = DART_COLOUR;
        } else {
            colour = KITE_COLOUR;
        }

        float d0 = abs(cross2d(t1, t2, fragmentPosition)) / length(t1 - t2);
        float d2 = abs(cross2d(t0, t1, fragmentPosition)) / length(t0 - t1);
        float distNearestEdge = min(d0, d2);

        if (distNearestEdge < EDGE) {
            return mix(colour, vec4(0., 0., 0., 255.), 1. - distNearestEdge / EDGE);
        } else {
            return colour;
        }
    }

    void main() {
        int triangleType = start_triangleType;
        vec2 t0 = start_t0;
        vec2 t1 = start_t1;
        vec2 t2 = start_t2;
        float sign = start_sign;

        int prev_triangleType = triangleType;
        vec2 prev_t2 = t2;
        vec2 prev_t0 = t0;
        vec2 prev_t1 = t1;

        for (int i = 0; i < ITERATIONS; i++) {
            prev_triangleType = triangleType;
            prev_t2 = t2;
            prev_t0 = t0;
            prev_t1 = t1;

            if (sign * cross2d(t0, t1, fragmentPosition) < 0. ||
                sign * cross2d(t0, t2, fragmentPosition) > 0. ||
                sign * cross2d(t1, t2, fragmentPosition) < 0.) {

                triangleType = NONE;
                break;
            } else if (triangleType == HALF_DART) {
                vec2 p0 = t2; // apex of the triangle, sitting on its wide base
                vec2 p1 = t0 + PHI_INV * (t1 - t0); // point near the right of the base

                if (sign * cross2d(p1, p0, fragmentPosition) < 0.) {
                    t0 = t1;
                    t1 = t2;
                    t2 = p1;
                    triangleType = HALF_DART;
                } else {
                    vec2 tmp = t0;
                    t0 = t2;
                    t2 = tmp;
                    t1 = p1;
                    triangleType = HALF_KITE;
                    sign *= -1.; // this one is flipped
                }
            } else {
                vec2 p0 = t2 + PHI_INV * (t0 - t2); // point near the bottom of the left side
                vec2 p1 = t1 + PHI_INV * (t2 - t1); // point near the top of the right side
                vec2 p2 = t1; // this point divides the two kite halves: bottom-left corner

                if (sign * cross2d(p0, p1, fragmentPosition) > 0.) {
                    t0 = t2;
                    t1 = p0;
                    t2 = p1;
                    triangleType = HALF_DART;
                } else if (sign * cross2d(p0, p2, fragmentPosition)  > 0.) {
                    t2 = t1;
                    t0 = p0;
                    t1 = p1;
                    triangleType = HALF_KITE;
                    sign *= -1.; // this one is flipped
                } else {
                    t2 = t1;
                    t1 = t0;
                    t0 = p0;
                    triangleType = HALF_KITE;
                }
            }
        }

        if (triangleType == NONE) {
            gl_FragColor = vec4(0, 0, 0, 255);
        } else {
            vec4 colour = calcColour(triangleType, t0, t1, t2);
            vec4 prev_colour = calcColour(prev_triangleType, prev_t0, prev_t1, prev_t2);

            float ratio = 1. - fract(time);
            float ease = 3. * ratio * ratio - 2. * ratio * ratio * ratio;
            gl_FragColor = mix(colour, prev_colour, ease);
        }
    }
    </script>
    <script src="jquery-2.1.4.js"></script>
    <script src="penrose.js"></script>
</head>
<body>
    <canvas width="1024" height="720"></canvas>
</body>
</html>
