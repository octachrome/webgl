<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
        <style>
            body {
                margin: 0;
            }
            canvas {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <script type="text/x-shader" id="vertex-shader-src">
        attribute float offset;
        varying vec2 coords;
        varying float vOffset;

        void main() {
            coords = uv;
            vOffset = offset;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
        </script>
        <!-- Useful function reference: http://patriciogonzalezvivo.com/2015/thebookofshaders/05/kynd.png -->
        <script type="text/x-shader" id="fragment-shader-src">
        uniform float time;
        uniform float maxTime;
        uniform float spreadSpeed;
        uniform sampler2D noiseTexture;
        varying vec2 coords;
        varying float vOffset;

        float noise2d(vec2 pos, float scale) {
            // pos is from fragmentPosition, which ranges from -1 to 1
            // move it to texture pixel space (0 to 1023, but it can wrap)
            vec2 scaled = scale * pos;
            vec2 topLeft = floor(scaled);
            vec2 topRight = topLeft + vec2(1.0, 0.0);
            vec2 bottomLeft = topLeft + vec2(0.0, 1.0);
            vec2 bottomRight = topLeft + vec2(1.0, 1.0);

            float res = 20.;
            vec2 normTL = texture2D(noiseTexture, (2.0 * topLeft + vec2(1.0, 1.0)) / res).xy * 2.0 - 1.0;
            vec2 normTR = texture2D(noiseTexture, (2.0 * topRight + vec2(1.0, 1.0)) / res).xy * 2.0 - 1.0;
            vec2 normBL = texture2D(noiseTexture, (2.0 * bottomLeft + vec2(1.0, 1.0)) / res).xy * 2.0 - 1.0;
            vec2 normBR = texture2D(noiseTexture, (2.0 * bottomRight + vec2(1.0, 1.0)) / res).xy * 2.0 - 1.0;

            vec2 offset = scaled - topLeft;
            float yScale = 3.0 * offset.y * offset.y - 2.0 * offset.y * offset.y * offset.y;
            float left = mix(dot(normTL, scaled - topLeft), dot(normBL, scaled - bottomLeft), yScale);
            float right = mix(dot(normTR, scaled - topRight), dot(normBR, scaled - bottomRight), yScale);

            float xScale = 3.0 * offset.x * offset.x - 2.0 * offset.x * offset.x * offset.x;
            return mix(left, right, xScale);
        }

        // iters should be [1,5] or so
        // persist should be [0,1]
        float octaveNoise2d(vec2 pos, float scale, int iters, float persist) {
            float result = 0.0;
            float factor = 1.0;
            for (int i = 0; i < 64; i++) {
                if (i >= iters) {
                    break;
                }
                result += factor * noise2d(pos, scale);
                scale *= 2.0;
                factor *= persist;
            }
            return result;
        }

        void main() {
            vec2 pos = 2. * (coords - .5);
            float t = time - vOffset;
            float len = length(pos)*(100. - 100. * pow(t / (11. - spreadSpeed), .01));
            float alpha = len < 0. ? 0. : (len < 1. ? (pow(len, 10.)) * (1. - length(pos)) : 0.);
            gl_FragColor = vec4(1, 1, 1, alpha);
        }
        </script>
        <script src="three.js"></script>
        <script type="text/javascript" src="DAT.GUI.min.js"></script>
        <script>
        var noiseTexture = createNoiseTexture();
        noiseTexture.needsUpdate = true;

        var uniforms = {
            time: {
                value: 0
            },
            maxTime: {
                value: 2
            },
            spreadSpeed: {
                value: 3
            },
            noiseTexture: {
                value: noiseTexture
            }
        };

        var gui = new DAT.GUI();
        gui.add(uniforms.maxTime, 'value').name('Delay').min(1).max(10);
        gui.add(uniforms.spreadSpeed, 'value').name('Spread speed').min(1).max(10);

        var textureLoader = new THREE.TextureLoader();
        var bgTexture = textureLoader.load('street.jpg');
        onTexturesLoaded();

        function onTexturesLoaded() {
            var windowWidth = 900; // window.innerWidth
            var windowHeight = 900; // window.innerHeight
            var renderer = new THREE.WebGLRenderer();
            renderer.autoClear = false;
            renderer.setSize(windowWidth, windowHeight);
            document.body.appendChild(renderer.domElement);

            // Background.
            var sceneBg = new THREE.Scene();
            var camWidth = 10;
            var camHeight = 10 * windowHeight / windowWidth;
            var cameraBg = new THREE.OrthographicCamera(-camWidth / 2, camWidth / 2, camHeight / 2, -camHeight / 2, 1, 1000);

            var textureMaterial = new THREE.MeshBasicMaterial({map: bgTexture});
            // Prevent the ortho camera from messing up the depth buffer.
            textureMaterial.depthTest = false;
            textureMaterial.depthWrite = false;
            var bgMesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(camWidth, camHeight), textureMaterial);
            bgMesh.position.z = -100;
            sceneBg.add(bgMesh);

            // Foreground.
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(75, windowWidth / windowHeight, 0.1, 1000);

            var shaderMaterial = new THREE.ShaderMaterial({
                vertexShader: document.getElementById('vertex-shader-src').textContent,
                fragmentShader: document.getElementById('fragment-shader-src').textContent,
                uniforms: uniforms,
                transparent: true
            });

            var objects = [];
            for (var i = 0; i < 10; i++) {
                geom = new THREE.PlaneBufferGeometry(2, 2);
                var offset = Math.random() * uniforms.maxTime.value;
                var offsets = new Float32Array([offset, offset, offset, offset]);
                geom.addAttribute('offset', new THREE.BufferAttribute(offsets, 1));

                var obj = new THREE.Mesh(geom, shaderMaterial);
                obj.offset = offset;
                var theta = Math.random() * 6;
                var radius = 1 + Math.random() * 2;
                obj.position.x = radius * Math.cos(theta);
                obj.position.z = -5 - radius * Math.sin(theta);
                obj.position.y = Math.random() * 2 - 2;
                scene.add(obj);
                objects.push(obj);
            }

            camera.position.z = 0;

            var clock = new THREE.Clock();

            function render() {
                requestAnimationFrame(render);
                var time = uniforms.time.value = clock.getElapsedTime() + 10;
                for (var i = 0; i < objects.length; i++) {
                    var obj = objects[i];
                    var relativeTime = time - obj.offset;
                    if (relativeTime > uniforms.maxTime.value) {
                        obj.offset = time + Math.random() * uniforms.maxTime.value;
                        // Using setXYZW to set a 4-valued array is a cheap t.
                        obj.geometry.getAttribute('offset').setXYZW(0, obj.offset, obj.offset, obj.offset, obj.offset);
                        obj.geometry.getAttribute('offset').needsUpdate = true;
                        var theta = Math.random() * 6;
                        var radius = 1 + Math.random() * 2;
                        obj.position.x = radius * Math.cos(theta);
                        obj.position.z = -5 - radius * Math.sin(theta);
                        obj.position.y = Math.random() * 2 - 2;
                        relativeTime = time - obj.offset;
                    }
                    if (relativeTime < 0) {
                        obj.visible = false;
                    }
                    else {
                        obj.visible = true;
                    }
                }
                renderer.clear();
                renderer.render(sceneBg, cameraBg);
                renderer.render(scene, camera);
            }
            render();
        }

        function createNoiseTexture() {
            var noiseArray = [];
            for (var i = 0; i < 1024 * 1024; i++) {
                var angle = 2 * Math.PI * Math.random();
                noiseArray.push(127 + Math.sin(angle) * 127, 127 + Math.cos(angle) * 127, 0, 255);
            }
            return new THREE.DataTexture(new Uint8Array(noiseArray), 1024, 1024, THREE.RGBAFormat);
        }
        </script>
    </body>
</html>
