<!DOCTYPE html>
<html lang="en">
<!-- based on https://github.com/mrdoob/three.js/blob/master/examples/webgl_interactive_points.html -->
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        color: #ffffff;
        background-color: #000000;
        margin: 0px;
        overflow: hidden;
      }
      #info {
        position: absolute;
        top: 0px;
        width: 100%;
        padding: 5px;
        font-family: Monospace;
        font-size: 13px;
        text-align: center;
        font-weight: bold;
      }
    </style>
  </head>

  <body>
    <div id="container"></div>
    <div id="info">Hold right mouse button to rotate</div>

    <script src="three.js"></script>
    <script src="OrbitControls.js"></script>

    <script type="x-shader/x-vertex" id="vertexshader">

      attribute float size;
      attribute vec3 customColor;

      varying vec3 vColor;

      void main() {

        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

        vColor = customColor * 200. / -mvPosition.z;

        gl_PointSize = size * 300. / -mvPosition.z;

        gl_Position = projectionMatrix * mvPosition;

      }

    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">

      uniform vec3 color;
      uniform sampler2D texture;

      varying vec3 vColor;

      void main() {
        vec2 coords = gl_PointCoord * 2. - 1.;
        float alpha = smoothstep(1., .8, length(coords));
        gl_FragColor = vec4( color * vColor, alpha);
        if (alpha < .5) {
          discard;
        }

      }

    </script>


    <script>

      var renderer, scene, camera;

      var particles, uniforms, tracer;

      var PARTICLE_SIZE = 20;
      var PARTICLE_COUNT = 20;
      var TRACER_SPEED = 1;

      var raycaster, intersects;
      var mouse, INTERSECTED, clock;

      init();
      animate();

      function init() {
        clock = new THREE.Clock();

        container = document.getElementById( 'container' );

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
        camera.position.z = 250;

        particles = createParticles(PARTICLE_COUNT);
        scene.add( particles );

        tracer = createTracer();
        scene.add(tracer);

        //

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.enableDamping = true;
        controls.enablePan = false;
        controls.enableZoom = false;

        //

        raycaster = new THREE.Raycaster();
        raycaster.params.Points.threshold = 3;
        mouse = new THREE.Vector2();

        //

        window.addEventListener( 'resize', onWindowResize, false );
        document.addEventListener( 'mousemove', onDocumentMouseMove, false );

      }

      function createParticles(count) {
        var positions = new Float32Array( count * 3 );
        var colors = new Float32Array( count * 3 );
        var sizes = new Float32Array( count );

        var vertex;
        var color = new THREE.Color();
        var RADIUS = 100;

        for ( var i = 0; i < count; i++ ) {
          var theta = Math.PI * 2 * i / count;
          positions[i * 3] = RADIUS * Math.sin(theta);
          positions[i * 3 + 1] = RADIUS * Math.random() - RADIUS / 2;
          positions[i * 3 + 2] = RADIUS * Math.cos(theta);

          color.setHSL( .1, 1, .5 );
          color.toArray( colors, i * 3 );

          sizes[ i ] = PARTICLE_SIZE * 0.5;

        }

        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
        geometry.addAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );
        geometry.addAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );

        //

        var material = new THREE.ShaderMaterial( {

          uniforms: {
            color:   { value: new THREE.Color( 0xffffff ) }
          },
          vertexShader: document.getElementById( 'vertexshader' ).textContent,
          fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
          transparent: true
        } );

        return new THREE.Points( geometry, material );
      }

      function createTracer() {
        var positions = new Float32Array( 3 );
        var colors = new Float32Array( 3 );
        var sizes = new Float32Array( 1 );

        var vertex;
        var color = new THREE.Color();

        positions[0] = 0;
        positions[1] = 0;
        positions[2] = 0;

        color.setHSL( .5, 1, .5 );
        color.toArray( colors, 0 );

        sizes[0] = 10;

        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
        geometry.addAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );
        geometry.addAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );

        //

        var material = new THREE.ShaderMaterial( {

          uniforms: {
            color:   { value: new THREE.Color( 0xffffff ) }
          },
          vertexShader: document.getElementById( 'vertexshader' ).textContent,
          fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
          transparent: true

        } );

        return new THREE.Points( geometry, material );
      }

      function onDocumentMouseMove( event ) {

        event.preventDefault();

        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

      }

      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

      }

      function animate() {

        requestAnimationFrame( animate );

        controls.update();

        updateIntersections();
        updateTracer();

        renderer.render( scene, camera );
      }

      function updateIntersections() {
        var geometry = particles.geometry;
        var attributes = geometry.attributes;

        raycaster.setFromCamera( mouse, camera );

        intersects = raycaster.intersectObject( particles );

        if ( intersects.length > 0 ) {

          if ( INTERSECTED != intersects[ 0 ].index ) {

            attributes.size.array[ INTERSECTED ] = PARTICLE_SIZE * .5;

            INTERSECTED = intersects[ 0 ].index;

            attributes.size.array[ INTERSECTED ] = PARTICLE_SIZE * 1.25;
            attributes.size.needsUpdate = true;

          }

        } else if ( INTERSECTED !== null ) {

          attributes.size.array[ INTERSECTED ] = PARTICLE_SIZE * .5;
          attributes.size.needsUpdate = true;
          INTERSECTED = null;

        }

      }

      function updateTracer() {
        var progress = clock.getElapsedTime() * TRACER_SPEED;
        var point1 = Math.floor(progress % PARTICLE_COUNT);
        var point2 = Math.floor((progress + 1) % PARTICLE_COUNT);
        var t = progress % 1;

        var particlePositions = particles.geometry.attributes.position;
        var tracerPosition = tracer.geometry.attributes.position;

        tracerPosition.array[0] =
          t * particlePositions.array[point2 * 3] + (1 - t) * particlePositions.array[point1 * 3];
        tracerPosition.array[1] =
          t * particlePositions.array[point2 * 3 + 1] + (1 - t) * particlePositions.array[point1 * 3 + 1];
        tracerPosition.array[2] =
          t * particlePositions.array[point2 * 3 + 2] + (1 - t) * particlePositions.array[point1 * 3 + 2];
        tracerPosition.needsUpdate = true;
      }
    </script>

  </body>

</html>
