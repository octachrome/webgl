<!DOCTYPE html>
<html lang="en">
<!-- based on https://github.com/mrdoob/three.js/blob/master/examples/webgl_interactive_points.html -->
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        color: #ffffff;
        background-color: #000000;
        margin: 0px;
        overflow: hidden;
      }
      #info {
        position: absolute;
        top: 0px;
        width: 100%;
        padding: 5px;
        font-family: Monospace;
        font-size: 13px;
        text-align: center;
        font-weight: bold;
      }
      #toast {
        position: absolute;
        top: 50px;
        width: 100%;
        padding: 5px;
        font-family: Monospace;
        font-size: 20px;
        text-align: center;
        font-weight: bold;
      }
      .fullscreen {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
      }
    </style>
  </head>

  <body>
    <div class="fullscreen" style="display: none" data-bind="visible: $data">
      <div class="fullscreen" data-bind="visible: checkGameState('playing')">
        <div id="container"></div>
        <div id="info">Left-drag to select, right-drag to rotate</div>
        <div id="toast" data-bind="visible: toastMessage, text: toastMessage"></div>
      </div>
      <div class="fullscreen" data-bind="visible: checkGameState('won')">
        <h1>OH YEAH! You did it.</h1>
        <button data-bind="click: leaveGame">Back</button>
      </div>
      <div class="fullscreen" data-bind="visible: checkGameState('abandoned')">
        <h1>The other player left the game.</h1>
        <button data-bind="click: leaveGame">Back</button>
      </div>
      <div class="fullscreen" data-bind="visible: checkGameState(null)">
        <p>Players online:</p>
        <ul>
          <!-- ko foreach: serverState.shared.connectedUsers -->
            <li><span data-bind="text: id"></span><span data-bind="visible: inGame"> (in game)</span></li>
          <!-- /ko -->
        </ul>
        <p data-bind="visible: !readyToPlay()">Waiting for more players<p>
        <button data-bind="visible: readyToPlay(), click: startGame">Play!</button>
      </div>
    </div>

    <script src="three.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/knockout/3.4.0/knockout-min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/knockout.mapping/2.4.1/knockout.mapping.min.js"></script>

    <script type="x-shader/x-vertex" id="vertexshader">
      attribute float size;
      attribute vec3 customColor;

      varying vec3 vColor;

      void main() {

        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

        vColor = customColor * 200. / -mvPosition.z;

        gl_PointSize = size * 300. / -mvPosition.z;

        gl_Position = projectionMatrix * mvPosition;

      }

    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">

      uniform vec3 color;
      uniform sampler2D texture;

      varying vec3 vColor;

      void main() {
        vec2 coords = gl_PointCoord * 2. - 1.;
        float alpha = smoothstep(1., .8, length(coords));
        gl_FragColor = vec4( color * vColor, alpha);
        if (alpha < .5) {
          discard;
        }

      }

    </script>


    <script>
      var socket = io();
      socket.on('connect', function() {
      });

      var renderer, scene, camera;

      var particles, uniforms, tracer;

      var PARTICLE_SIZE = 20;
      var TRACER_SPEED = 1;

      var raycaster, intersects;
      var mouse, INTERSECTED, clock;
      var dragging, path, prevIndices;
      var vm;

      vm = {
        serverState: ko.mapping.fromJS({
          shared: {
            connectedUsers: []
          },
          user: {
            id: null,
            inGame: null
          },
          game: {
            id: null,
            state: null,
            points: [],
            known: []
          }
        }),
        toastMessage: ko.observable()
      };
      ko.applyBindings(vm);

      var toastTimeout;
      function showToast(msg) {
        clearTimeout(toastTimeout);
        vm.toastMessage(msg);
        toastTimeout = setTimeout(function () {
          vm.toastMessage(null);
        }, 2000);
      }

      socket.on('serverState', function(serverState) {
        ko.mapping.fromJS(serverState, vm.serverState);
      });

      socket.on('message', function(msg) {
        if (msg.type === 'incorrectGuess') {
          showToast('Sorry, that is not correct');
        }
      });

      vm.serverState.user.inGame.subscribe(function (inGame) {
        if (inGame) {
          setTimeout(function () {
            initGame();
            animate();
          });
        }
      });

      init();

      function startGame() {
        socket.emit('command', {
          command: 'start'
        });
      }

      function leaveGame() {
        socket.emit('command', {
          command: 'leave'
        });
      }

      function checkGameState(state) {
        if (!vm.serverState.user.inGame()) {
          return !state;
        }
        else {
          return state === vm.serverState.game.state();
        }
      }

      function readyToPlay() {
        return vm.serverState.shared.connectedUsers().filter(function (player) {
          return !player.inGame();
        }).length >= 2;
      }

      function init() {
        clock = new THREE.Clock();

        container = document.getElementById( 'container' );

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
        camera.position.z = 250;

        //

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.enableDamping = true;
        controls.enablePan = false;
        controls.enableZoom = false;

        //

        raycaster = new THREE.Raycaster();
        raycaster.params.Points.threshold = 3;
        mouse = new THREE.Vector2();

        //

        window.addEventListener( 'resize', onWindowResize, false );
        document.addEventListener( 'mousemove', onDocumentMouseMove, false );

        $(renderer.domElement).on('mousedown', function (event) {
          if (event.button === THREE.MOUSE.LEFT) {
            dragging = true;
            path = [];
            prevIndices = new Set();
          }
        });
        $(window).on('mouseup', function () {
          if (dragging) {
            dragging = false;
            socket.emit('command', {
              command: 'guess',
              path: path
            });
          }
        });
      }

      function initGame() {
        while (scene.children.length) {
          scene.remove(scene.children[0]);
        }

        particles = createParticles();
        scene.add( particles );

        tracer = createTracer();
        scene.add(tracer);
      }

      function createParticles() {
        var points = vm.serverState.game.points();
        var count = points.length;

        var positions = new Float32Array( count * 3 );
        var colors = new Float32Array( count * 3 );
        var sizes = new Float32Array( count );

        var vertex;
        var color = new THREE.Color();
        var RADIUS = 100;

        for ( var i = 0; i < count; i++ ) {
          positions[i * 3] = points[i][0];
          positions[i * 3 + 1] = points[i][1];
          positions[i * 3 + 2] = points[i][2];

          color.setHSL( .1, 1, .5 );
          color.toArray( colors, i * 3 );

          sizes[ i ] = PARTICLE_SIZE * 0.5;
        }

        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
        geometry.addAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );
        geometry.addAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );

        //

        var material = new THREE.ShaderMaterial( {

          uniforms: {
            color:   { value: new THREE.Color( 0xffffff ) }
          },
          vertexShader: document.getElementById( 'vertexshader' ).textContent,
          fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
          transparent: true
        } );

        return new THREE.Points( geometry, material );
      }

      function createTracer() {
        var positions = new Float32Array( 3 );
        var colors = new Float32Array( 3 );
        var sizes = new Float32Array( 1 );

        var vertex;
        var color = new THREE.Color();

        positions[0] = 0;
        positions[1] = 0;
        positions[2] = 0;

        color.setHSL( .5, 1, .5 );
        color.toArray( colors, 0 );

        sizes[0] = 10;

        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
        geometry.addAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );
        geometry.addAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );

        //

        var material = new THREE.ShaderMaterial( {

          uniforms: {
            color:   { value: new THREE.Color( 0xffffff ) }
          },
          vertexShader: document.getElementById( 'vertexshader' ).textContent,
          fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
          transparent: true

        } );

        return new THREE.Points( geometry, material );
      }

      function onDocumentMouseMove( event ) {

        event.preventDefault();

        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

      }

      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

      }

      function animate() {
        if (!vm.serverState.user.inGame()) {
          return;
        }

        requestAnimationFrame( animate );

        controls.update();

        updateIntersections();
        updateTracer();

        renderer.render( scene, camera );
      }

      function updateIntersections() {
        if (dragging) {
          raycaster.setFromCamera( mouse, camera );
          intersects = raycaster.intersectObject( particles );
          var indices = intersects.map(function (intersect) {
            return intersect.index;
          })

          var newIndices = indices.filter(function (index) {
            return !prevIndices.has(index);
          });
          path = path.concat(newIndices);

          prevIndices = new Set(indices);
        }
      }

      function updateTracer() {
        var progress = clock.getElapsedTime() * TRACER_SPEED;
        var knownPoints = vm.serverState.game.known();
        var points = vm.serverState.game.points();
        var idx1 = Math.floor(progress % knownPoints.length);
        var idx2 = Math.floor((progress + 1) % knownPoints.length);
        var point1 = knownPoints[idx1];
        var point2 = knownPoints[idx2];
        var t = progress % 1;

        tracer.visible = (idx1 < idx2);

        var tracerPosition = tracer.geometry.attributes.position;

        tracerPosition.array[0] =
          t * points[point2][0] + (1 - t) * points[point1][0];
        tracerPosition.array[1] =
          t * points[point2][1] + (1 - t) * points[point1][1];
        tracerPosition.array[2] =
          t * points[point2][2] + (1 - t) * points[point1][2];
        tracerPosition.needsUpdate = true;
      }
    </script>

  </body>

</html>
